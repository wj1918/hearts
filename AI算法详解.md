# AI算法与不完美信息模型

## 核心挑战

```
完美信息游戏(国际象棋)：        不完美信息游戏(红心大战)：
┌─────────────────────────────┐        ┌─────────────────────────────┐
│ 你能看到所有信息             │        │ 你只能看到自己的牌           │
│ 唯一真实的游戏状态           │        │ 存在多种可能的游戏状态       │
│ 搜索一棵树                   │        │ 必须推理信念                │
└─────────────────────────────┘        └─────────────────────────────┘
```

---

## 第一部分：AI算法栈

```
┌─────────────────────────────────────────────────────────────────┐
│                         决策                                    │
│                           ▲                                     │
│                           │                                     │
│              ┌────────────┴────────────┐                        │
│              │      iiMonteCarlo       │  ← 处理不确定性        │
│              │   (30个世界样本)        │                        │
│              └────────────┬────────────┘                        │
│                           │                                     │
│         ┌─────────────────┼─────────────────┐                   │
│         ▼                 ▼                 ▼                   │
│    ┌─────────┐       ┌─────────┐       ┌─────────┐              │
│    │   UCT   │       │   UCT   │  ...  │   UCT   │ ← 树搜索    │
│    │ 世界1   │       │ 世界2   │       │世界30   │              │
│    └────┬────┘       └────┬────┘       └────┬────┘              │
│         │                 │                 │                   │
│         ▼                 ▼                 ▼                   │
│    ┌─────────┐       ┌─────────┐       ┌─────────┐              │
│    │  模拟   │       │  模拟   │  ...  │  模拟   │ ← 随机推演  │
│    └─────────┘       └─────────┘       └─────────┘              │
└─────────────────────────────────────────────────────────────────┘
```

---

## 第二部分：不完美信息模型

### 你知道的与不知道的

```
你的视角(玩家0)：
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  你的手牌(已知)：      ♠AKQ ♥J32 ♦T98 ♣7654                     │
│                                                                 │
│  已打出的牌(已知)：    ♠2 ♥A ♦K ♣Q (来自之前的墩牌)            │
│                                                                 │
│  传递的牌(已知)：      你传出♥QK9，收到♦T98                    │
│                                                                 │
│  玩家1手牌：           ? ? ? ? ? ? ? ? ? ? ? ? ?  (13张牌)     │
│  玩家2手牌：           ? ? ? ? ? ? ? ? ? ? ? ? ?  (13张牌)     │
│  玩家3手牌：           ? ? ? ? ? ? ? ? ? ? ? ? ?  (13张牌)     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 三种对手模型

```
┌─────────────────────────────────────────────────────────────────┐
│                        OM-0 (基础)                              │
│                       iiHeartsState                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  逻辑："我没有 + 未打出 = 别人有"                               │
│                                                                 │
│  牌分布：                                                       │
│    未知牌在对手之间平均分配                                     │
│    P(玩家1有♠J) = P(玩家2有♠J) = P(玩家3有♠J)                  │
│                                                                 │
│  弱点：忽略行为线索                                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                      OM-1 (简单)                                │
│                   simpleIIHeartsState                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  逻辑："跟踪缺门 - 如果他们没跟牌，就是没有该花色"              │
│                                                                 │
│  示例：                                                         │
│    墩牌：首出♠A，玩家2打出♥5                                   │
│    推断：玩家2没有黑桃                                          │
│    更新：P(玩家2有任何♠) = 0                                   │
│                                                                 │
│  牌概率矩阵：                                                   │
│    ┌─────────┬─────────┬─────────┬─────────┐                   │
│    │   牌    │ 玩家1   │ 玩家2   │ 玩家3   │                   │
│    ├─────────┼─────────┼─────────┼─────────┤                   │
│    │   ♠J    │  0.45   │  0.00   │  0.55   │ ← P2缺门         │
│    │   ♠T    │  0.50   │  0.00   │  0.50   │                   │
│    │   ♥Q    │  0.33   │  0.33   │  0.33   │                   │
│    └─────────┴─────────┴─────────┴─────────┘                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     OM-2 (高级)                                 │
│                  advancedIIHeartsState                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  逻辑："他们为什么打那张牌？"                                   │
│                                                                 │
│  推断：                                                         │
│    • 玩家首出小黑桃 → 可能没有♠Q                               │
│    • 玩家早早扔掉♥K → 可能想让红桃缺门                         │
│    • 玩家传♣A给我 → 可能梅花很少                               │
│                                                                 │
│  跟踪：                                                         │
│    • 传牌历史(谁传了什么)                                       │
│    • 打牌模式(激进vs防守)                                       │
│    • 射月企图(收集所有红桃)                                     │
│                                                                 │
│  贝叶斯更新：                                                   │
│    P(牌 | 行为) ∝ P(行为 | 牌) × P(牌)                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 第三部分：它们如何协同工作

### 逐步决策过程

```
情况：轮到你，必须打一张牌

步骤1：查询信念状态
┌─────────────────────────────────────────────────────────────────┐
│  iiHeartsState.GetProbabilities()                               │
│                                                                 │
│  返回：                                                         │
│    ♠Q: P1=0.4, P2=0.0, P3=0.6  (P2黑桃缺门)                    │
│    ♥A: P1=0.3, P2=0.5, P3=0.2                                  │
│    ...                                                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
步骤2：生成30个一致的世界
┌─────────────────────────────────────────────────────────────────┐
│  for (i = 0; i < 30; i++) {                                     │
│      world[i] = beliefState.SampleConsistentWorld()             │
│  }                                                              │
│                                                                 │
│  世界1：               世界2：               世界3：            │
│  P1: ♠QJ ♥32 ♦A ♣K    P1: ♠J ♥A32 ♦K ♣Q    P1: ♠T ♥32 ♦AK ♣Q  │
│  P2: ♥AK ♦QJ ♣T9      P2: ♥K ♦QJT ♣K9      P2: ♥AK ♦QJ ♣K9    │
│  P3: ♠T ♥Q ♦T9 ♣AQ    P3: ♠QT ♥Q ♦9 ♣AT    P3: ♠QJ ♥AQ ♦T9 ♣AT│
│                                                                 │
│  (每个世界都与观察一致)                                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
步骤3：在每个世界上运行UCT
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  世界1 + UCT(333次模拟)：  最佳=♠K, 得分=2.1                   │
│  世界2 + UCT(333次模拟)：  最佳=♠K, 得分=1.8                   │
│  世界3 + UCT(333次模拟)：  最佳=♦9, 得分=3.2                   │
│  ...                                                            │
│  世界30 + UCT(333次模拟)： 最佳=♠K, 得分=2.4                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
步骤4：聚合结果
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ♠K: 在22/30个世界中被选择，平均得分 = 2.1                     │
│  ♦9: 在5/30个世界中被选择，平均得分 = 3.4                      │
│  ♣7: 在3/30个世界中被选择，平均得分 = 2.8                      │
│                                                                 │
│  决策：打出♠K (在可能的世界中最稳健)                           │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 第四部分：UCT深入剖析

### 搜索树

```
                         根节点：当前状态
                        /          |          \
                       /           |           \
                   打出♠K        打出♦9       打出♣7
                  /    \           |          /    \
                 /      \          |         /      \
            对手♠A   对手♠2    对手♥3    对手♣Q   对手♣2
               |        |         |         |        |
              ...      ...       ...       ...      ...
                        |
                    推演
                   (随机到结束)
                        |
                    得分：3分
                        |
                   反向传播
                   (更新所有祖先节点)
```

### UCT选择公式

```
在每个节点，选择使以下公式最大化的子节点：

         ─────────────────────────────────────────
        │                      ┌─────────────────┐│
        │                      │ ln(父节点访问数) ││
UCT  =  │   平均奖励     +   C │─────────────────││
        │                      │  子节点访问数    ││
        │                      └─────────────────┘│
         ─────────────────────────────────────────
              利用                  探索

C = 探索常数(通常为0.5 - 2.0)
```

### 计算示例

```
父节点访问数：1000
子节点A：400次访问，总奖励800 (平均2.0)
子节点B：100次访问，总奖励150 (平均1.5)

UCT(A) = 2.0 + 1.0 × √(ln(1000)/400) = 2.0 + 0.13 = 2.13
UCT(B) = 1.5 + 1.0 × √(ln(1000)/100) = 1.5 + 0.26 = 1.76

选择子节点A (UCT值更高)

但如果子节点B只有10次访问：
UCT(B) = 1.5 + 1.0 × √(ln(1000)/10) = 1.5 + 0.83 = 2.33

将选择子节点B (探索不足)
```

---

## 第五部分：世界生成算法

### 一致世界采样

```cpp
World SampleConsistentWorld() {
    // 从已知信息开始
    for each player p:
        hand[p] = known_cards[p]  // 我们看到他们打过/传过的牌

    // 按概率分配未知牌
    unknown_cards = all_cards - played - my_hand

    for each card c in unknown_cards:
        // 基于概率分布采样玩家
        probs = GetProbabilities(c)  // 例如，[0.4, 0.0, 0.6]

        player = WeightedRandomChoice(probs)

        // 验证约束
        if (hand[player].size < max_hand_size AND
            !player_voided_suit[player][suit(c)]):
            hand[player].add(c)
        else:
            // 重新采样或重新分配

    return World(hand[0], hand[1], hand[2], hand[3])
}
```

### 墩牌后的概率更新

```
墩牌前：
  ♠Q: P1=0.33, P2=0.33, P3=0.33

打出的墩牌：
  首出：♠A (你)
  P1打出：♠5 (跟牌)
  P2打出：♥2 (没跟牌 - 缺门！)
  P3打出：♠9 (跟牌)

墩牌后：
  ♠Q: P1=0.50, P2=0.00, P3=0.50
       ↑           ↑         ↑
   仍然可能      不可能    仍然可能
```

---

## 第六部分：推演策略

### 标准推演(随机)

```
while game not over:
    legal_moves = get_legal_moves()
    move = random_choice(legal_moves)
    apply(move)
return final_score
```

### Epsilon-贪心推演

```
while game not over:
    legal_moves = get_legal_moves()

    if random() < epsilon:
        move = random_choice(legal_moves)     # 探索
    else:
        move = heuristic_best(legal_moves)    # 利用

    apply(move)
return final_score
```

### 红心大战特定启发式

```cpp
Move heuristic_best(moves) {
    // 避免得分
    if (can_play_low_card)
        return lowest_card

    // 安全时扔掉危险牌
    if (not_winning_trick AND have_high_hearts)
        return highest_heart

    // 避免黑桃皇后
    if (spades_led AND have_queen AND have_lower_spade)
        return lower_spade

    return random_choice(moves)
}
```

---

## 第七部分：完整示例

```
游戏状态：
  你(P0)：   ♠AK3 ♥72 ♦J98 ♣T654
  墩牌：     P3首出♠Q
  必须打出： 一张黑桃(跟牌)

你的选择：
  ♠A - 将赢得墩牌(吃到♠Q = 13分！)
  ♠K - 将赢得墩牌(吃到♠Q = 13分！)
  ♠3 - 可能输掉墩牌(避免♠Q)

AI过程：

1. 生成30个世界，P1/P2持有不同的黑桃

2. 对每个世界，UCT搜索：

   世界1 (P1有♠J，P2有♠T)：
     打♠3 → P1打♠J → P1赢 → 你避免13分！
     ♠3的UCT得分：0分

   世界2 (P1有♠2，P2有♠T)：
     打♠3 → P2打♠T → P2赢 → 你避免13分！
     ♠3的UCT得分：0分

   世界3 (P1有♠2，P2有♠4)：
     打♠3 → 最大的是♠Q → P3赢得自己的墩牌
     ♠3的UCT得分：0分

3. 聚合30个世界的结果：
   ♠A: 平均13.0分 (总是赢，总是吃♠Q)
   ♠K: 平均13.0分 (总是赢，总是吃♠Q)
   ♠3: 平均0.2分  (通常别人吃)

4. 决策：打出♠3
```

---

## 总结表

| 组件 | 目的 | 关键洞察 |
|-----------|---------|-------------|
| **iiMonteCarlo** | 处理隐藏牌 | 采样多个可能的世界 |
| **UCT** | 搜索博弈树 | 用UCB平衡探索/利用 |
| **Playout** | 评估叶节点 | 随机模拟到结束 |
| **OM-0** | 基本信念 | 未知牌等概率 |
| **OM-1** | 跟踪缺门 | 未跟牌时更新概率 |
| **OM-2** | 行为推断 | "他们为什么打那张牌？" |

---

## 代码参考

### 关键文件

| 文件 | 类 | 目的 |
|------|-------|---------|
| `UCT.h/cpp` | `UCT` | 蒙特卡洛树搜索 |
| `iiMonteCarlo.h/cpp` | `iiMonteCarlo` | 世界采样包装器 |
| `iiGameState.h/cpp` | `iiHeartsState` | OM-0基础模型 |
| `iiGameState.h/cpp` | `simpleIIHeartsState` | OM-1缺门跟踪 |
| `iiGameState.h/cpp` | `advancedIIHeartsState` | OM-2行为模型 |
| `Hearts.h/cpp` | `HeartsPlayout` | 随机推演 |
| `Hearts.h/cpp` | `HeartsPlayoutCheckShoot` | 射月感知推演 |

### 关键参数

```cpp
// 典型配置
UCT *uct = new UCT();
uct->SetNumSamples(333);      // 每个世界的模拟次数
uct->SetC1(0.5);              // 探索常数

iiMonteCarlo *ai = new iiMonteCarlo(
    uct,                      // 基础算法
    new iiHeartsState(),      // 信念模型(OM-0, OM-1, 或 OM-2)
    30                        // 世界样本数量
);
```

---

*这种技术在游戏AI研究中被称为"信息集蒙特卡洛树搜索"(ISMCTS)或"确定化"。*

---

## 相关文档

- [ANALYSIS.md](ANALYSIS.md) - 代码库完整架构分析（英文）
- [世界模型详解.md](世界模型详解.md) - 世界模型简化说明
- [server/API_SPEC.md](server/API_SPEC.md) - REST API规范

---

*更新时间：2026年1月*
